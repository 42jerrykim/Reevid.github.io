---
title: "Part 1 더 큰 그림"
date: 2022-03-10
---

1부에서는 단위 테스트의 현황을 빠르게 살펴본다.

* 1장 : 단위 테스트의 목표를 정의하고, 좋은 테스트와 좋지 않은 테스트를 구별하는 방법을 추려서 설명한다. 일반적으로 좋은 단위 테스트의 속성들과 커버리지 지표를 다룬다.
* 2장 : 단위 테스트의 정의를 살펴본다. 이 정의에 대해 사소한 의견 차이가 있어 두 개의 분파가 생겼으므로, 이와 관련된 내용도 살펴본다. 
* 3장에서는 테스트 구성과 테스트 픽스처 재사용, 테스트 매개 변수화 등과 같은 몇 가지 기본 주제를 다룬다.

# 1장 : 단위 테스트의 목표

단위 테스트는 단순히 테스트를 작성하는 것보다 더 큰 범주다. 단위 테스트에 시간을 투자할 때는 항상 최대한 이득을 얻도록 노력해야 하며, 테스트에 드는 노력을 가능한 한 줄이고 그에 따르는 이득을 최대화해야 한다. 두 가지를 모두 달성하기란 쉬운 일이 아니다.

## 1.1 단위 테스트 현황

대부분 프로그래머는 단위 테스트를 실천하고 중요성을 알고 있다. 단위 테스트를 적용해야 하는지는 더 이상 논쟁거리가 아니다. 그냥 쓰고 버리는 프로젝트가 아니면, 단위 테스트는 늘 적용해야 한다.

많은 프로젝트에는 자동화된 테스트가 있으며 심지어 많은 테스트가 실행된다. 그러나 테스트를 해도 개발자들이 원하는 결과를 얻지 못하는 경우가 많다.

어떤 것이 단위 테스트를 좋게 만드는지에 대한 논쟁은 매우 중요하다. 하지만 오늘날 소프트웨어 개발 업계에서 많이 논의되지는 않는다.

이 책은 기업용 애플리케이션을 작업하는 경우에 최대로 활용할 수 있지만, 몇몇 아이디어는 어떤 소프트웨어 프로젝트에서든 적용할 수 있다.

> **기업용 애플리케이션이란?**
>
> 기업용 애플리케이션은 조직 내부 프로세스를 자동화하거나 지원하기 위한 응용프로그램이다. 다양한 형태이지만, 일반적으로 다음과 같은 특성이 있다.
>
> * 높은 비즈니스 복잡도
> * 긴 프로젝트 수명
> * 중간 크기의 데이터
> * 낮은 수준이나 중간 수준 정도의 성능 요구

## 1.2 단위 테스트의 목표

흔히 단위 테스트 활동이 더 나은 설계로 이어진다고 한다. 이는 사실이다. 하지만 단위 테스트의 주목표는 아니다. 더 나은 설계는 단지 좋은 부수 효과일 뿐이다.

그럼 단위 테스트의 목표는 무엇인가? 소프트웨어 프로젝트의 지속 가능한 성장을 가능하게 하는 것이다. 

그림 1.1은 테스트가 없는 일반 프로젝트의 성장 추이를 보여준다. 처음에는 발목을 잡을 것이 없으므로 빨리 시작할 수 있다. 그러나 시간이 지나면서 점점 더 많은 시간을 들여야 처음에 보여준 것과 같은 정도의 진척을 낼 수 있다.

|![](/assets/images/2022-03-10-173235.png)|
|:--:|
| 그림 1.1 테스트 유무에 따른 프로젝트 간 성장 추이의 차이, 테스트가 없는 프로젝트의 경우 시작은 유리하지만, 이내 진척이 없을 정도로 느려진다.|

하나의 버그를 수정하면 더 많은 버그를 양산하고, 소프트웨어의 한 부분을 수정하면 다른 부분들이 고장 난다. 테스트는 안전망 역할을 하며, 새로운 기능을 도입하거나 새로운 요구 사항에 더 잘 맞게 리팩터링한 후에도 기존 기능이 잘 작동하는지 확인하는 데 도움이 된다.

**지속성과 확장성이 핵심이며, 이를 통해 장기적으로 개발 속도를 유지할 수 있다.**

### 1.2.1 좋은 테스트와 좋지 않은 테스트를 가르는 요인

단위 테스트가 프로젝트 성장에 도움이 되는 것은 맞지만, 테스트를 작성하는 것만으로는 충분하지않다. 잘못 작성한 테스트는 여전히 같은 결과를 낳는다.

|![](/assets/images/2022-03-10-173901.png)|
|:--:|
| 그림 1.2 테스트가 좋은지 나쁜지에 따른 프로젝트 간 성장 추이의 차이. 테스트가 잘못 작성된 프로젝트는 초반에는 테스트가 잘 작성된 프로젝트의 속성을 보여주지만, 결국 침체 단계에 빠진다.|

일부 테스트는 아주 중요하고 소프트웨어 품질에 매우 많은 기여를 한다. 그 밖에 다른 테스트는 그렇지 않다. 잘못된 경고가 발생하고, 회귀 오류를 알아내는 데 도움이 되지 않으며, 유지 보수가 어렵고 느리다. 

> **제품 코드 대 테스트 코드**
> 
> 사람들은 종종 제품 코드와 테스트 코드가 다르다고 생각한다. 테스트는 제품 코드에 추가된 것으로 간주되며 소유 비용이 없다. 또한 사람들은 종종 테스트가 많으면 많을수록 좋다고 생각한다. 하지만 그렇지 않다. 코드는 자산이 아니라 책임이다. 코드가 더 많아질수록, 소프트웨어 내의 잠재적인 버그에 노출되는 표면적이 더 넓어지고 프로젝트 유지비가 증가한다. 따라서 가능한 한 적은 코드로 문제를 해결하는 것이 좋다.
> 테스트도 역시 코드다. 특정 문제를 해결하는 것, 즉 애플리케이션의 정확성을 보장하는 것을 목표로하는 코드베이스의 일부로 봐야 한다. 다른 코드와 마찬가지로 단위 테스트도 버그에 취약하고 유지보스가 필요하다.

## 1.3 테스트 스위트 품질 측정을 위한 커버리지 지표

가장 널리 사용되는 두 가지 커버리지 지표(코드 커버리지와 분기 커버리지)를 어떻게 계산하고 어떻게 사용하는지 살펴본다. 

프로그래머가 특정 커버리지 숫자를 목표로 하는 것이 해로운 이유와 테스트 스위트 품질을 결정하는 데 커버리지 지표에 의존할 수 없는 이유를 알아본다.

> **커버리지 지표**는 테스트 스위트가 소스 코드를 얼마나 실행하는지를 백분율로 나타낸다.

커버리지 지표는 각기 다른 유형이 있으며, 테스트 스위트의 품질을 평가하는 데 자주 사용된다. 일반적으로 커버리지 숫자가 높을수록 더 좋다. 커버리지 지표는 중요한 피드백을 주더라도 테스트 스위트 품질을 효과적으로 측정하는 데 사용될 수 없다. 커버리지 지표를 높이기 위해서 테스트를 아무렇게나 작성한다면 커버리지를 100%로 만들수 있기 때문이다.

### 1.3.1 코드 커버리지 지표에 대한 이해

우선 가장 많이 사용되는 커버리지 지표로 코드 커버리지(Code Coverage)가 있으며, 테스트 커버리지(Test Coverage)로도 알려져 있다. 

$$코드\ 커버리지(테스트\ 커버리지) = {실행\ 코드\ 라인 수\over전체\ 라인\ 수}$$

예제 1.1에 ```IsStringLong()``` 메서드와 이를 다루는 테스트가 있다. 메서드는 입력 매개변수로 제공된 문자열이 긴지 여부를 판별한다(여기서 '길다'는 표현은 다섯 자보다 긴 문자열을 의미한다). 

|![](/assets/images/2022-03-10-175707.png)|
|:--:|
|예제 1.1 메서드를 부분적으로 다루는 테스트|

```csharp
public void Test()
{
    bool result = isStringLong("abc");
    Assert.Equal(false, result);
}
```

메서드 전체 라인 수는 (중괄호를 포함해) 5이다. 테스트가 실행하는 라인 수는 4이다. 테스트는 true를 반환하는 구문을 제외한 모든 코드 라인을 통과한다. 따라서 코드 커버리지는 4/5 = 0.8 = 80%이다.

이제 메서드를 리팩터링하고 불필요한 if 문을 한 줄로 처리하면 어떻게 될까?

```csharp
public static bool IsStringLong(string input)
{
    return input.Length > 5;
}

public void Test()
{
    bool result = IsStringLong("abc");
    Assert. Equal(false, result);
}
```

테스트는 이제 코드 세 줄(반환문과 중괄호 두개)을 모두 점검하기 때문에 코드 커버리지가 100%로 증가했다. **이 간단한 예제는 커버리지 숫자에 대해 얼마나 쉽게 장난칠 수 있는지 보여준다.**

### 1.3.2 분기 커버리지 지표에 대한 이해

분기 커버리지는 코드 커버리지의 단점을 극복하는 데 도움이 되므로 코드 커버리지보다 더 정확한 결과를 제공한다. 원시 코드 라인 수를 사용하는 대신 if 문과 Switch 문과 같은 제어 구조에 중점을 둔다. 

$$분기\ 커버리지 = {통과\ 분기\over전체\ 분기\ 수}$$

분기 커버리지 지표를 계산하려면 코드베이스에서 모든 가능한 분기를 합산하고 그중
테스트가 얼마나 많이 실행되는지 확인해야 한다. 이전의 예를 다시 보자.

```csharp
public static bool IsStringLong(string input)
{
    return input.Length > 5;
}

public void Test()
{
    bool result = IsStringLong("abc");
    Assert. Equal(false, result);
}
```

```IsStringLong()```에 두 개의 분기가 있는데, 테스트는 이런 분기 중 하나에 대해서만 적용되므로 분기 커버리지 지표는 1/2 = 0.5 = 50%이다. 이전과 같이 if 문을 사용하는 더 짧은 표기법을 사용하든, 테스트 코드는 어떻게 작성해도 50%이다.

### 1.3.3 커버리지 지표에 관한 문제점

분기 커버리지로 코드 커버리지보다 더 나은 결과를 얻을수 있지만, 다음과 같은 이유로 어떤 커버리지 지표도 테스트 스위트의 품질을 결정 할 수 없다.

* 테스트 대상 시스템의 모든 가능한 결과를 검증한다고 보장할 수 없다.
* 외부 라이브러리의 코드 경로를 고려할 수 있는 커버리지 지표는 없다.

