---
title: "1장 설계와 아키텍처란?"
---

**설계*design*와 아키텍처*architecture* 사이에는 오랫동안 많은 혼란이 있었다.** 결론 부터 얘기하면 **둘 사이에는 차이가 없다.**

**'아키텍처'는 저수준의 세부사항과는 분리된 고수준의 무언가**를 가리킬 때 흔히 사용되는 반면, **'설계'는 저수준의 구조 또는 결정사항** 등을 의미할 때가 많다. 하지만 아키텍트가 실제로 하는 일을 살펴보면 이러한 구분은 무의미하다.

**저수준의 세부사항과 고수준의 구조는 모두 소프트웨어 전체 설계의 구성요소다.** 이 둘은 단절 없이 이어진 직물과 같으며, 이를 통해 대상 시스템의 구조를 정의한다. 개별로는 존재할 수 없고, 실제로 이 둘을 구분 짓는 경계는 뚜렷하지 않다. 고수준에서 저수준으로 향하는 의사결정의 연속성만이 있을 뿐이다.

# 목표는?

그렇다면 이러한 의사결정의 목표는? 좋은 소프트웨어의 목표는?

> 소프트웨어 아키텍처의 목표는 필요한 시스템을 만들고 유지보수하는 데 투입되는 인력을 최소화하는 데 있다.

설계 품질을 재는 척도는 고객의 요구를 만족시키는 데 드는 비용을 재는 척도와 다름이 없다. 이 비용이 낮을뿐만 아니라 시스템의 수명이 다할 때까지 낮게 유지 하면 좋다. 새로운 기능을 출시 할 때마다 비용이 증가한다면 나쁜 설계다.

# 사례 연구

먼저 엔지니어링 직원 수가 늘어나는 추세를 살펴보자. 당신은 분명 이러한 추세를 굉장히 긍정적인 상황으로 여길 것이다. 그림 1.1과 같은 성장은 굉장한 성공을 이뤄냈음을 가리키는 지표라고 말이다!

| ![그림 1.1 엔지니어링 직원 수의 증가 추이](https://uchanlee.dev/static/0a50572e45511d65424f1fe40d68ba13/0a47e/image-1.1.png) | 
|:--:| 
| **그림 1.1 엔지니어링 직원 수의 증가 추이** |

이제 같은 기간 회사의 생산성을 보자. 생산성은 단순히 코드 라인 수로만 측정했다(그림 1.2).

| ![그림 1.2 동일한 기간의 생산성](https://uchanlee.dev/static/a66e4ce519202d4a67b6ea4f4b566947/0a47e/image-1.2.png) | 
|:--:| 
| **그림 1.2 동일한 기간의 생산성** |

무언가가 명백히 잘못되었다. 매번 새로운 기능을 출시할 때마다 개발자의 수는 지속적으로 증가했지만, 코드 생산성은 마치 한 곳으로 수렴하는 것처럼 보인다.

이제 정달 두려운 그래프를 볼 차례다. 그림 1.3은 같은 기간에 코드 한 라인 리들이 어떻게 변했는지를 보여준다.

| ![그림 1.3 동일한 기간의 코드 라인당 비용](https://uchanlee.dev/static/557d5c2df4405aead2f7fc7ec6d2f515/0a47e/image-1.3.png) | 
|:--:| 
| **그림 1.3 동일한 기간의 코드 라인당 비용** |

이러한 방향으로는 지금 당장의 수익은 낼지 몰라도 결국 회사의 성장을 멈추게 하거나 완전히 망하게 만든다. 이처럼 생산성을 현저하게 변화시킨 요인은 대체 무엇인가? 여덟 번째 출시한 제품의 코드는 처음 제품보다 왜 40배나 더 많은 비용이 드는가?

# 엉망진창이 되어 가는 신호

시스템을 급하게 만들거나, 결과물의 총량을 순전히 프로그래머 수만으로 결정하거나, 코드와 설계의 구조를 깔끔하게 만들려는 생각을 전혀 하지 않으면 그림 1.4와 같은 비용 곡선을 띈다.

| ![그림 1.4 출시별 생산성](https://uchanlee.dev/static/1fafc953a9b50fa441a3fa67e3e06901/0a47e/image-1.4.png) | 
|:--:| 
| **그림 1.4 출시별 생산성** |

위 그림은 개발자의 생산성을 거의 100%로 시작했지만, 출시할 때마다 하락하며 결국에는 0으로 되는 모습을 나타낸다. 개발자 입장에서 보면 이러한 현상은 큰 절망감을 안겨준다. 모두가 전력을 기울여 열심히 일하고 있기 때문이다. 하지만 이러한 노력에도 불구하고 더이상 발전이 없는 상황에 처하게 된다. 개발자의 노력은 기능 개발보다는 엉망이 된 상황에 대처하는 데 소모되며 결국엔 개발자들이 쏟은 노력의 가치가 결국 보잘것없게 된다.

# 경영자의 시각

이러한 상황이 나쁘게 보인다면 경영자 입장에서 살펴보자. 그림 1.5는 같은 기간에 개발하는 데 쓰인 월별 인건비를 보여준다.

| ![그림 1.5 출시별 월 인건비](https://uchanlee.dev/static/30140aa506a82da6915fff71ef6675ed/0a47e/image-1.5.png) | 
|:--:| 
| **그림 1.5 출시별 월 인건비** |

첫 번쨰 출시에서는 매월 수십만 달러의 인건비만으로 제품을 생산한 반면 두 번째 출시에서는 수십만 달러가 더 들었고 점점 인건비가 증가하는 모습이다. 그림 1.5의 곡선과 그림 1.2의 출시별 코드 라인 수를 비교해 보면 초기 출시에는 매월 수십만 달러의 비용으로 많은 기능을 탑재할 수 있엇지만 마지막 출시에서는 2천만 달러를 들이고도 얻은게 거의 없다.

# 무엇이 잘못되었나?

개발자는 “코드는 나중에 정리하면 돼. 당장은 시장에 출시하는 게 먼저야!”라는 흔해 빠진 거짓말에 속는다. 이렇게 속아 넘어간 개발자라면 나중에 코드를 정리하는 경우는 한 번도 없는데, 시장의 압박은 절대로 수그러들지 않기 때문이다. 시장 출시가 먼저'라는 생각을 하는 이유는 바로 뒤에 여러 무리의 경쟁자가 뒤쫓고 있고, 경쟁자보다 앞서 가려면 가능한 한 빠르게 달려야 하기 때문이다.

결국 개발자는 절대로 태세를 전환하지 않는다. 이전에 작성한 코드로 돌아가 정리하는 일은 일어나지 않는데, 바로 다음에 만들어야 할 새로운 기능이 기다리고 있고, 다음 기능, 또 다음 기능, 또 다음 기능이 계속 기다리고 있기 때문이다. 결국 엉망진창이 되고, 생산성은 0을 향해 수렴하기 시작한다.

개발자가 속는 더 잘못된 거짓말은 “지저분한 코드를 작성하면 단기간에는 빠르게 갈 수 있고, 장기적으로 볼 때만 생산성이 낮아진다”는 견해다. 이거짓말을 받아들인 개발자는 엉망인 코드를 만드는 태세에서, 나중에 기회가 되면 엉망이 된 코드를 정리하는 태세로 전환할 수 있다고 자신의 능력을 과신하게 된다. 하지만 이는 그저 진실을 오인한 것일 뿐이다. 진실은 다음과 같다. 엉망으로 만들면 깔끔하게 유지할 때보다 항상 더 느리다. 시간 척도를 어떻게 보든지 관계없이 말이다.

> 빨리 가는 유일한 방법은 제대로 가는 것이다.

개발자는 처음부터 다시 시작하여 전체 시스템을 재설계하는 것이 해답이라고 생각할지도 모른다. 하지만 이 생각 또한 토끼의 말과 다름없다. 엉망으로 내몰았던 바로 그 과신이 경주를 다시 시작한다면 더 나은 코드를 만들 수 있다고 말하고 있는 것이다.

> 자신을 과신한다면 재설계하더라도 원래의 프로젝트와 똑같이 엉망으로 내몰린다.

# 결론

어떤 경우에도 개발 조직이 할 수 있는 최고의 선택지는 조직에 스며든 과신을 인지하여 방지하고, 소프트웨어 아키텍처의 품질을 심각하게 고민하기 시작하는 것이다.

이를 위해 좋은 소프트웨어 아키턱처가 무엇인지 이해해야 한다. 비용은 최소화하고 생산성은 최대화 할 수 있는 설계와 아키텍처를 가진 시스템을 만들려면, 이러한 결과로 이끌어줄 시스템 아키텍처가 지닌 속성을 알고 있어야 한다.