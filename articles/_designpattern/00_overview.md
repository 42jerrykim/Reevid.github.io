---
title: "Overview"
last_modified_at: 2022-03-01
date: 2022-01-01
header:
  teaser: /assets/images/design-pattern-nedir-2021-12-18-143754.jpg
---

소프트웨어 개발을 할 때 사용되는 디자인 패턴이란 과거에 소프트웨어 개발 과정에서 발견된 설계 노하우를 축적하여 그 방법에 이름이 붙여서 이후에 재사용하기 좋은 형태로 특정 규약을 만들어서 정리해둔 것을 말한다. 즉 효율적인 소프트웨어를 만들기 위한 방법론이라고 생각하면 될 듯하다. 특정 한두 개의 패턴을 외우기보다는 다양하게 이해를 하고 알맞은 때와 장소에 맞게 자신의 코드에 녹여내면 될 듯하다.

각기 다른 소프트웨어 모듈이나 기능을 가진 다양한 응용 소프트웨어 시스템들을 개발할 때도 서로 간에 공통되는 설계 문제가 존재하며 이를 처리하는 해결책 사이에도 공통점이 있다. 이러한 유사점을 패턴이라 한다. 패턴은 공통의 언어를 만들어주며 팀원 사이의 의사소통을 원활하게 해주는 아주 중요한 역할을 한다.

# 디자인 패턴이란

소프트웨어를 설계할 때 특정 맥락에서 자주 발생하는 고질적인 문제들이 또 발생했을 때 재사용할 할 수 있는 훌륭한 해결책이다. “바퀴를 다시 발명하지 마라(Don’t reinvent the wheel)”라는 말이 있듯이 이미 만들어져서 잘 되는 것을 처음부터 다시 만들 필요가 없다는 의미이다.

|![](https://pbs.twimg.com/media/EJ5Gw_RXsAEeSJ5.png)|
|:--:|
|더 좋은 바퀴(동가란 바퀴)가 있어도 기존에 사용하던 바퀴(네모)를 포기하지 않는 모습|

또한 디자인 패턴은 상황에 따라서 더 효율적인 방법이 있을 수도 있다. 하지만 지금의 일이 바쁘다고 해서 다른 대안을 살펴보지 않는 것은 위 그림처럼 네모난 바퀴를 사용하여 일을 처리하는 모습이 될 것이다. 따라서 시간을 갖고 더 효율적인 방법을 찾을 수 있도록 노력하는 시간을 가져 보자.

# 디자인 패턴 구조

* 콘텍스트(context)
  * 문제가 발생하는 여러 상황을 기술한다. 즉, 패턴이 적용될 수 있는 상황을 나타낸다. 때에 따라서는 패턴이 유용하지 못한 상황을 나타내기도 한다.
* 문제(problem)
  * 패턴이 적용되어 해결될 필요가 있는 여러 디자인 이슈들을 기술한다. 이때 여러 제약 사항과 영향력도 문제 해결을 위해 고려해야 한다.
* 해결(solution)
  * 문제를 해결하도록 설계를 구성하는 요소들과 그 요소들 사이의 관계, 책임, 협력 관계를 기술한다. 해결은 반드시 구체적인 구현 방법이나 언어에 의존적이지 않으며 다양한 상황에 적용할 수 있는 일종의 템플릿이다.

# 디자인 패턴의 종류

GoF 디자인 패턴이 가장 대중적인 패턴이다. GoF(Gang of Fout)는 네 명의 사람이 모여서 만든 단어로 에리히 감마(Erich Gamma), 리차드 헬름(Richard Helm), 랄프 존슨(Ralph Johnson), 존 블리시디스(John Vissides)가 포함되어 있다. 이 네 사람들이  소프트웨어 개발 영역에서 디자인 패턴을 구체화하고 체계화하였다.
            
23가지의 디자인 패턴을 정리하고 각각의 디자인 패턴을 생성(Creational), 구조(Structural), 행위(Behavioral) 3가지로 분류했다.

|구분|생성 패턴|구조 패턴|행위 패턴|
|:--:|:--:|:--:|:--:|
|Class|팩토리 메서드 패턴(Factory Method)|적응자 패턴(Adapter)|인터프리터 패턴(Interpreter)<br>템플릿 메소드 패턴(Template Method)
|Object|추상팩토리 패턴(Abstract Factory)<br>빌더 패턴(Builder)<br>원형 패턴(Prototype)<br>싱글톤 패턴(Singleton)|적응자 패턴(Adapter)<br>브리지 패턴(Bridge)<br>컴포지트 (Composite)<br>데코레이터 패턴(Decorator)<br>퍼사드 패턴(Facade)<br>플라이 웨이트 패턴(Flyweight)<br>프록시 패턴(Proxy)|역할 사슬 패턴(Chain of Responsibility)<br>커맨드 패턴(Command)<br>옵저버 패턴(Observer)<br>상태 패턴(State)<br>스트레이트지 패턴(Strategy)<br>비지터 패턴(Visitor)<br>이터레이터 패턴(Iterator)<br>미디에이터 패턴(Mediator)<br>Memonto|

> Adapter는 Class와 Object 둘다 존재한다.

## 생성 패턴(Creational Patterns)

객체 생성에 관련된 패턴입니다. 객체의 생성과 조합을 캡슐화해 특정 객체가 생성되거나 변경되어도 프로그램 구조에 영향을 크게 받지 않도록 유연성을 제공합니다.

1. **싱글톤 패턴(Singleton)** : 클래스의 인스턴스가 하나임을 보장하고 접근할 수 있는 전역적인 접근점을 제공하는 패턴으로, 디자인 패턴의 가장 많이 알려진 패턴입니다.
2. **추상팩토리 패턴(Abstract Factory)** : 구체적인 클래스를 지정하지 않고 관련성이 있거나, 독립적인 객체들을 생성하기 위한 인터페이스를 제공하는 패턴입니다.
3. **빌더 패턴(Builder)** : 복학 객체의 생성과정과 표현과정을 분리시켜 동일한 생성과정에서 다양한 표현을 생성할 수 있는 패턴입니다.
4. **팩토리 메서드 패턴(Factory Method)** : 객체를 생성하는 인터페이스를 정의하지만, 인스턴스를 만드는 클래스는 서브클래스에서 결정하도록 하는 패턴입니다. 팩토리 메서드에서는 인스턴스를 만드는 것을 서브 클래스에서 하게 됩니다.
5. **원형 패턴(Prototype)** : 생성할 객체의 종류를 명시하는 데 원형이 되는 예시물을 이용하고 새로운 객체를 이 원형들을 복사함으로써 생성하는 패턴입니다.

## 구조 패턴(Structural Patterns)

클래스나 객체를 조합해 더 큰 구조를 만드는 패턴입니다. 예를 들어 서로 다른 인터페이스를 지닌 2개의 객체를 묶어 단일 인터페이스를 제공하거나 서로 다른 객체들을 묶어 새로운 기능을 제공하는 패턴입니다.

1. **적응자 패턴(Adapter)** : 클래스의 인터페이스를 사용자가 기대하는 다른 인터페이스로 변환하는 패턴으로, 호환성이 없는 인터페이스 때문에 함께 동작할 수 없는 클래스들이 함께 작동하도록 해주는 패턴입니다.
2. **브리지 패턴(Bridge)** : 구현부에 추상층을 분리하여 각자 독립적으로 변형할 수 있도록 하는 패턴입니다. - 컴포지트 패턴(Composite) : 객체들의 관계를 트리 구조로 구성하여 부분-전체 계층을 표현하는 패턴으로, 사용자가 단일 / 복합객체 모두 동일하게 다루도록 하는 패턴입니다.
3. **데코레이터 패턴(Decorator)** : 주어진 상황 및 용도에 따라 어떤 객체에 책임을 덧붙이는 패턴으로, 기능확장이 필요할 때 서브클래스 대신 쓸 수 있는 대안이 될 수 있습니다.
4. **퍼사드 패턴(Facade)** : 서브시스템에 있는 인터페이스 집합에 통합된 하나의 인터페이스를 제공합니다. 서브시스템을 좀 더 쉽게 사용하기 위해 고수준의 인터페이스를 정의합니다.
5. **프록시 패턴(Proxy)** : 어떤 다른 객체로 접근하는 것을 통제하기 위해 그 객체의 매니저 또는 자리 채움자를 제공하는 패턴입니다.
1. **플라이웨이트(Flyweight)** : 
1. **컴포지트(Composite)** : 

## 행위 패턴(Behavioral Patterns)

객체나 클래스 사이의 알고리즘이나 책임 분배에 관련된 패턴입니다. 한 객체가 혼자 수행할 수 없는 작업을 여러개의 객체로 어떻게 분배하는지, 또 그렇게 하면서도 객체 사이의 결합도를 최소화하는것에 중점을 두는 방식입니다.

1. **옵저버 패턴(Observer)** : 객체들 사이에 1 : N 의 의존관계를 정의하여 어떤 객체의 상태가 변할 때, 의존관계에 있는 모든 객체들이 통지받고 자동으로 갱신될 수 있게 만드는 패턴입니다.
2. **상태 패턴(State)** : 객체의 내부 상태가 변경될 때 행동을 변경하도록 허락합니다. 객체는 자신의 클래스가 변경되는 것처럼 보이게 됩니다.
3. **스트레이트지 패턴(Strategy)** : 동일 계열의 알고리즘들을 정의하고, 각각 캡슐화하며 이들을 상호교환 가능하도록 만드는 것입니다. 알고리즘을 사용하는 사용자로부터 독립적으로 알고리즘이 변경될 수 있도록 하는 패턴입니다.
4. **템플릿 메소드 패턴(Template Method)** : 객체의 연산에서 알고리즘의 뼈대만 정의하고, 나머지는 서브클래스에서 이루어지게 하는 패턴입니다. 템플릿패턴은 알고리즘의 구조는 변경하지 않고 알고리즘의 각 단계를 서브클래스에서 재정의하게 됩니다.
5. **비지터 패턴(Visitor)** : 객체구조를 이루는 원소에 대해 수행할 연산을 표현합니다. 방문자는 연산에 적용할 원소의 클래스를 변경하지 않고 새로운 연산을 재정의 할 수 있습니다.
6. **역할 사슬 패턴(Chain of Responsibility)** : 요청을 처리하는 기회를 하나 이상의 객체에 부여하여 요청을 보내는 쪽과 받는 쪽의 결합을 피하는 패턴입니다. 요청을 받는 객체를 연쇄적으로 묶고 객체를 처리할 수 있을 때까지 요청을 전달합니다.
7. **커맨드 패턴(Command)** : 요청을 객체로 캡슐화하여 서로 다른 사용자의 매개변수화, 요청 저장 또는 로깅, 연산의 취소를 지원하게 만드는 패턴입니다.
8. **인터프리터 패턴(Interpreter)** : 주어진 언어에 대해서 문법을 위한 표현수단을 정의하고, 해당 언어로 된 문장을 해석하는 해석기를 사용하는 패턴입니다.
9. **이터레이터 패턴(Iterator)** : 내부 표현부를 노출하지 않고 어떤 객체 집합의 원소들을 순차적으로 접근할 수 있는 방법을 제공하는 패턴입니다.
10. **미디에이터 패턴(Mediator)** : 한 집합에 속해있는 객체들의 상호 작용을 캡슐화하는 객체를 정의하는 패턴입니다. 중재자는 객체들이 직접 서로 참조하지 않도록함으로써 객체들간의 느슨한 연결을 촉진시키며 객체들의 상호작용을 독립적으로 다양화 시킬 수 있도록 해줍니다.
1. **메멘토(Memento)** : 